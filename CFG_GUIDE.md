# Understanding Control Flow Graphs (CFG)

This guide helps you understand the Control Flow Graphs generated by the CFG Visualizer.

## What is a Control Flow Graph?

A Control Flow Graph (CFG) is a representation of all paths that might be traversed through a program during its execution. Each node in the graph represents a basic block of code, and edges represent possible control flow paths between blocks.

## Node Types in Our Visualizer

### 1. Function Label Node (Blue/Purple)
- **Appearance**: Blue/purple background with bold text
- **Purpose**: Indicates the start of a function's CFG
- **Example**: "Function: setValue"

### 2. Entry Node (Light Blue)
- **Appearance**: Light blue gradient background
- **Purpose**: Marks the entry point of a function
- **Example**: "Entry: setValue"

### 3. Exit Node (Pink)
- **Appearance**: Pink gradient background
- **Purpose**: Marks the exit point of a function
- **Example**: "Exit: setValue"

### 4. Condition Node (Green)
- **Appearance**: Green background
- **Purpose**: Represents conditional statements (if, while, for)
- **Example**: "If condition", "While condition"

### 5. Branch Nodes (White with colored backgrounds)
- **True Branch**: Light green background
- **False Branch**: Light red background
- **Purpose**: Represents the two possible paths after a condition

### 6. Statement Nodes (White)
- **Appearance**: White background with black border
- **Purpose**: Represents regular code statements
- **Examples**: "Expression", "Variable declaration"

### 7. Merge Node (White)
- **Appearance**: White background
- **Purpose**: Point where multiple control flow paths converge
- **Example**: After an if/else, where both branches meet

### 8. Return Node (Orange)
- **Appearance**: Orange/yellow background
- **Purpose**: Represents return statements
- **Example**: "Return"

## Edge Types

### Solid Edges
- **Appearance**: Black solid lines
- **Purpose**: Normal control flow from one block to another

### Labeled Edges
- **"true"**: Green label, indicates the path taken when condition is true
- **"false"**: Red label, indicates the path taken when condition is false

### Animated Edges
- **Appearance**: Dashed moving line
- **Purpose**: Back edges in loops (from end of loop back to condition)

## Reading a CFG

### Example 1: Simple If Statement
```solidity
function setValue(uint256 _value) public {
    if (_value > 100) {
        value = 100;
    } else {
        value = _value;
    }
}
```

**CFG Structure:**
```
Entry
  ↓
If condition (_value > 100)
  ↓         ↓
true      false
  ↓         ↓
value=100  value=_value
  ↓         ↓
  → Merge ←
     ↓
   Exit
```

### Example 2: Loop
```solidity
function sumArray(uint256[] memory arr) public pure returns (uint256) {
    uint256 sum = 0;
    for (uint256 i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```

**CFG Structure:**
```
Entry
  ↓
Variable declaration (sum = 0)
  ↓
For condition (i < arr.length)
  ↓              ↓
true           false
  ↓              ↓
Loop body    Exit loop
(sum += arr[i])  ↓
  ↓            Return
  └─────→ (back to condition)
```

## Interactive Features

### Clicking on Nodes
When you click on a node in the CFG:
1. The node is highlighted in the graph
2. A notification appears showing the line numbers
3. The corresponding code lines are indicated in the code editor

### Navigation Controls
- **Zoom In (+)**: Enlarges the graph
- **Zoom Out (-)**: Reduces the graph size
- **Fit View**: Automatically adjusts the view to show all nodes
- **Toggle Interactivity (🔒)**: Lock/unlock graph movement

### Minimap
- Located in the bottom right corner
- Shows an overview of the entire graph
- Colored boxes represent different node types:
  - Blue: Entry nodes
  - Pink: Exit nodes
  - White: Regular nodes

## Common Patterns

### Sequential Execution
Straight path from entry to exit with no branches:
```
Entry → Statement 1 → Statement 2 → Exit
```

### Branching
Two paths that merge later:
```
        Condition
         ↙     ↘
    true         false
       ↓           ↓
   Statement   Statement
       ↘         ↙
         Merge
           ↓
         Exit
```

### Loops
Path that goes back to a previous node:
```
    Entry
      ↓
   Condition ←─┐
      ↓         │
    Body        │
      └─────────┘
      ↓
    Exit
```

### Early Return
Path that goes directly to exit:
```
    Entry
      ↓
   Condition
      ↓     ↘
    Body     Return → Exit
      ↓
    Return → Exit
```

## Tips for Analysis

1. **Identify Entry/Exit Points**: Always start by finding the blue (entry) and pink (exit) nodes

2. **Follow the Flow**: Trace paths from entry to exit to understand execution sequences

3. **Check Loop Conditions**: Look for animated (dashed) edges that indicate loops

4. **Analyze Branches**: Pay attention to true/false branches to understand conditional logic

5. **Find Dead Code**: Nodes with no path to exit might indicate unreachable code

6. **Complexity**: More nodes and edges = more complex function = harder to test and maintain

## Use Cases

### 1. Security Auditing
- Identify all possible execution paths
- Check for reentrancy vulnerabilities
- Verify access control paths

### 2. Code Review
- Understand complex control flow
- Identify potential bugs
- Verify logic correctness

### 3. Testing
- Generate test cases for all paths
- Ensure complete code coverage
- Find edge cases

### 4. Documentation
- Visual representation for documentation
- Onboard new developers
- Explain complex functions

### 5. Optimization
- Identify hot paths
- Find redundant checks
- Optimize critical paths

## Further Reading

- [Control Flow Graph - Wikipedia](https://en.wikipedia.org/wiki/Control-flow_graph)
- [Program Analysis Basics](https://en.wikipedia.org/wiki/Program_analysis)
- [Solidity Documentation](https://docs.soliditylang.org/)
