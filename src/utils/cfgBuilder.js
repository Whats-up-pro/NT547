/**
 * CFG Builder - Constructs Control Flow Graphs from Solidity AST
 * 
 * This module traverses the Abstract Syntax Tree (AST) generated by @solidity-parser/parser
 * and constructs a Control Flow Graph (CFG) for each function in the smart contract.
 * 
 * Key Concepts:
 * - Basic Block: A sequence of statements with no jumps in or out in the middle
 * - Control Flow: The order in which statements are executed
 * - Edges: Represent possible execution paths between blocks
 */

let blockIdCounter = 0;

/**
 * Generates a unique ID for each basic block
 */
function generateBlockId() {
  return `block_${blockIdCounter++}`;
}

/**
 * Creates a new basic block
 */
function createBlock(label, statements = [], startLine = null, endLine = null) {
  return {
    id: generateBlockId(),
    label,
    statements,
    startLine,
    endLine,
    successors: []
  };
}

/**
 * Extracts location information from an AST node
 */
function getLocation(node) {
  if (node && node.loc) {
    return {
      start: node.loc.start.line,
      end: node.loc.end.line
    };
  }
  return null;
}

/**
 * Main CFG Builder class
 */
export class CFGBuilder {
  constructor() {
    this.blocks = [];
    this.edges = [];
  }

  /**
   * Builds CFG for a function
   */
  buildFunctionCFG(functionDef) {
    blockIdCounter = 0;
    this.blocks = [];
    this.edges = [];

    const loc = getLocation(functionDef);
    const entryBlock = createBlock(
      `Entry: ${functionDef.name || 'fallback'}`,
      [],
      loc ? loc.start : null,
      loc ? loc.start : null
    );
    this.blocks.push(entryBlock);

    let exitBlock = createBlock('Exit', []);
    
    if (functionDef.body && functionDef.body.statements) {
      const lastBlock = this.processStatements(
        functionDef.body.statements,
        entryBlock,
        exitBlock
      );
      
      // Connect last block to exit if not already connected
      if (lastBlock && lastBlock !== exitBlock) {
        this.addEdge(lastBlock, exitBlock, 'normal');
      }
    } else {
      this.addEdge(entryBlock, exitBlock, 'normal');
    }

    this.blocks.push(exitBlock);

    return {
      blocks: this.blocks,
      edges: this.edges
    };
  }

  /**
   * Processes a list of statements and creates basic blocks
   */
  processStatements(statements, currentBlock, exitBlock) {
    if (!statements || statements.length === 0) {
      return currentBlock;
    }

    for (let i = 0; i < statements.length; i++) {
      const stmt = statements[i];
      currentBlock = this.processStatement(stmt, currentBlock, exitBlock);
      
      // If we hit a return, break, or revert, stop processing
      if (this.isTerminalStatement(stmt)) {
        break;
      }
    }

    return currentBlock;
  }

  /**
   * Processes a single statement and updates the CFG
   */
  processStatement(stmt, currentBlock, exitBlock) {
    const loc = getLocation(stmt);

    switch (stmt.type) {
      case 'IfStatement':
        return this.processIfStatement(stmt, currentBlock, exitBlock);
      
      case 'WhileStatement':
        return this.processWhileLoop(stmt, currentBlock, exitBlock);
      
      case 'ForStatement':
        return this.processForLoop(stmt, currentBlock, exitBlock);
      
      case 'DoWhileStatement':
        return this.processDoWhileLoop(stmt, currentBlock, exitBlock);
      
      case 'ReturnStatement':
        const returnBlock = createBlock(
          'Return',
          [this.statementToString(stmt)],
          loc ? loc.start : null,
          loc ? loc.end : null
        );
        this.blocks.push(returnBlock);
        this.addEdge(currentBlock, returnBlock, 'return');
        this.addEdge(returnBlock, exitBlock, 'normal');
        return returnBlock;
      
      case 'ExpressionStatement':
        // Check if it's a require, revert, or assert
        if (stmt.expression && stmt.expression.type === 'FunctionCall') {
          const funcName = this.extractFunctionName(stmt.expression);
          if (funcName === 'require' || funcName === 'revert' || funcName === 'assert') {
            const checkBlock = createBlock(
              funcName.charAt(0).toUpperCase() + funcName.slice(1),
              [this.statementToString(stmt)],
              loc ? loc.start : null,
              loc ? loc.end : null
            );
            this.blocks.push(checkBlock);
            this.addEdge(currentBlock, checkBlock, 'check');
            
            // require/assert can continue or revert
            if (funcName === 'require' || funcName === 'assert') {
              const continueBlock = createBlock('Continue', []);
              this.blocks.push(continueBlock);
              this.addEdge(checkBlock, continueBlock, 'pass');
              this.addEdge(checkBlock, exitBlock, 'fail');
              return continueBlock;
            } else {
              // revert always exits
              this.addEdge(checkBlock, exitBlock, 'revert');
              return checkBlock;
            }
          }
        }
        // Regular expression statement
        currentBlock.statements.push(this.statementToString(stmt));
        if (loc) {
          if (!currentBlock.startLine) currentBlock.startLine = loc.start;
          currentBlock.endLine = loc.end;
        }
        return currentBlock;
      
      case 'VariableDeclarationStatement':
      case 'EmitStatement':
        currentBlock.statements.push(this.statementToString(stmt));
        if (loc) {
          if (!currentBlock.startLine) currentBlock.startLine = loc.start;
          currentBlock.endLine = loc.end;
        }
        return currentBlock;
      
      default:
        currentBlock.statements.push(this.statementToString(stmt));
        if (loc) {
          if (!currentBlock.startLine) currentBlock.startLine = loc.start;
          currentBlock.endLine = loc.end;
        }
        return currentBlock;
    }
  }

  /**
   * Processes an if statement
   */
  processIfStatement(stmt, currentBlock, exitBlock) {
    const loc = getLocation(stmt);
    const conditionBlock = createBlock(
      'If Condition',
      [this.expressionToString(stmt.condition)],
      loc ? loc.start : null,
      loc ? loc.start : null
    );
    this.blocks.push(conditionBlock);
    this.addEdge(currentBlock, conditionBlock, 'normal');

    // True branch
    const trueBlock = createBlock('True Branch', []);
    this.blocks.push(trueBlock);
    this.addEdge(conditionBlock, trueBlock, 'true');

    let trueLast = trueBlock;
    if (stmt.trueBody) {
      if (stmt.trueBody.type === 'Block') {
        trueLast = this.processStatements(stmt.trueBody.statements, trueBlock, exitBlock);
      } else {
        trueLast = this.processStatement(stmt.trueBody, trueBlock, exitBlock);
      }
    }

    // False branch
    let falseLast;
    if (stmt.falseBody) {
      const falseBlock = createBlock('False Branch', []);
      this.blocks.push(falseBlock);
      this.addEdge(conditionBlock, falseBlock, 'false');

      if (stmt.falseBody.type === 'Block') {
        falseLast = this.processStatements(stmt.falseBody.statements, falseBlock, exitBlock);
      } else {
        falseLast = this.processStatement(stmt.falseBody, falseBlock, exitBlock);
      }
    } else {
      falseLast = conditionBlock;
    }

    // Merge point
    const mergeBlock = createBlock('Merge', []);
    this.blocks.push(mergeBlock);

    if (trueLast && !this.isTerminalStatement(stmt.trueBody)) {
      this.addEdge(trueLast, mergeBlock, 'normal');
    }
    if (falseLast && falseLast !== conditionBlock) {
      this.addEdge(falseLast, mergeBlock, 'normal');
    } else if (falseLast === conditionBlock) {
      this.addEdge(conditionBlock, mergeBlock, 'false');
    }

    return mergeBlock;
  }

  /**
   * Processes a while loop
   */
  processWhileLoop(stmt, currentBlock, exitBlock) {
    const loc = getLocation(stmt);
    const conditionBlock = createBlock(
      'While Condition',
      [this.expressionToString(stmt.condition)],
      loc ? loc.start : null,
      loc ? loc.start : null
    );
    this.blocks.push(conditionBlock);
    this.addEdge(currentBlock, conditionBlock, 'normal');

    const bodyBlock = createBlock('Loop Body', []);
    this.blocks.push(bodyBlock);
    this.addEdge(conditionBlock, bodyBlock, 'true');

    let bodyLast = bodyBlock;
    if (stmt.body) {
      if (stmt.body.type === 'Block') {
        bodyLast = this.processStatements(stmt.body.statements, bodyBlock, exitBlock);
      } else {
        bodyLast = this.processStatement(stmt.body, bodyBlock, exitBlock);
      }
    }

    // Loop back
    this.addEdge(bodyLast, conditionBlock, 'loop');

    // Exit loop
    const afterLoop = createBlock('After Loop', []);
    this.blocks.push(afterLoop);
    this.addEdge(conditionBlock, afterLoop, 'false');

    return afterLoop;
  }

  /**
   * Processes a for loop
   */
  processForLoop(stmt, currentBlock, exitBlock) {
    const loc = getLocation(stmt);
    
    // Initialization
    if (stmt.initExpression) {
      currentBlock.statements.push(this.statementToString(stmt.initExpression));
    }

    const conditionBlock = createBlock(
      'For Condition',
      stmt.conditionExpression ? [this.expressionToString(stmt.conditionExpression)] : ['true'],
      loc ? loc.start : null,
      loc ? loc.start : null
    );
    this.blocks.push(conditionBlock);
    this.addEdge(currentBlock, conditionBlock, 'normal');

    const bodyBlock = createBlock('Loop Body', []);
    this.blocks.push(bodyBlock);
    this.addEdge(conditionBlock, bodyBlock, 'true');

    let bodyLast = bodyBlock;
    if (stmt.body) {
      if (stmt.body.type === 'Block') {
        bodyLast = this.processStatements(stmt.body.statements, bodyBlock, exitBlock);
      } else {
        bodyLast = this.processStatement(stmt.body, bodyBlock, exitBlock);
      }
    }

    // Loop expression (increment)
    if (stmt.loopExpression) {
      const loopBlock = createBlock(
        'Loop Update',
        [this.expressionToString(stmt.loopExpression)]
      );
      this.blocks.push(loopBlock);
      this.addEdge(bodyLast, loopBlock, 'normal');
      this.addEdge(loopBlock, conditionBlock, 'loop');
    } else {
      this.addEdge(bodyLast, conditionBlock, 'loop');
    }

    // Exit loop
    const afterLoop = createBlock('After Loop', []);
    this.blocks.push(afterLoop);
    this.addEdge(conditionBlock, afterLoop, 'false');

    return afterLoop;
  }

  /**
   * Processes a do-while loop
   */
  processDoWhileLoop(stmt, currentBlock, exitBlock) {
    const loc = getLocation(stmt);
    const bodyBlock = createBlock('Loop Body', [], loc ? loc.start : null, loc ? loc.end : null);
    this.blocks.push(bodyBlock);
    this.addEdge(currentBlock, bodyBlock, 'normal');

    let bodyLast = bodyBlock;
    if (stmt.body) {
      if (stmt.body.type === 'Block') {
        bodyLast = this.processStatements(stmt.body.statements, bodyBlock, exitBlock);
      } else {
        bodyLast = this.processStatement(stmt.body, bodyBlock, exitBlock);
      }
    }

    const conditionBlock = createBlock(
      'Do-While Condition',
      [this.expressionToString(stmt.condition)]
    );
    this.blocks.push(conditionBlock);
    this.addEdge(bodyLast, conditionBlock, 'normal');

    // Loop back
    this.addEdge(conditionBlock, bodyBlock, 'true');

    // Exit loop
    const afterLoop = createBlock('After Loop', []);
    this.blocks.push(afterLoop);
    this.addEdge(conditionBlock, afterLoop, 'false');

    return afterLoop;
  }

  /**
   * Adds an edge between two blocks
   */
  addEdge(from, to, label = '') {
    if (from && to) {
      from.successors.push({ block: to, label });
      this.edges.push({
        from: from.id,
        to: to.id,
        label
      });
    }
  }

  /**
   * Checks if a statement is terminal (stops execution flow)
   */
  isTerminalStatement(stmt) {
    if (!stmt) return false;
    if (stmt.type === 'ReturnStatement') return true;
    if (stmt.type === 'ExpressionStatement' && stmt.expression) {
      const funcName = this.extractFunctionName(stmt.expression);
      return funcName === 'revert';
    }
    return false;
  }

  /**
   * Converts a statement to a readable string
   */
  statementToString(stmt) {
    if (!stmt) return '';
    
    switch (stmt.type) {
      case 'ExpressionStatement':
        return this.expressionToString(stmt.expression);
      case 'VariableDeclarationStatement':
        return 'var declaration';
      case 'ReturnStatement':
        return `return ${stmt.expression ? this.expressionToString(stmt.expression) : ''}`;
      case 'EmitStatement':
        return 'emit event';
      default:
        return stmt.type;
    }
  }

  /**
   * Converts an expression to a readable string
   */
  expressionToString(expr) {
    if (!expr) return '';

    switch (expr.type) {
      case 'BinaryOperation':
        return `${this.expressionToString(expr.left)} ${expr.operator} ${this.expressionToString(expr.right)}`;
      case 'UnaryOperation':
        return `${expr.operator}${this.expressionToString(expr.subExpression)}`;
      case 'Identifier':
        return expr.name;
      case 'NumberLiteral':
        return expr.number;
      case 'BooleanLiteral':
        return String(expr.value);
      case 'StringLiteral':
        return `"${expr.value}"`;
      case 'FunctionCall':
        const funcName = this.extractFunctionName(expr);
        const args = expr.arguments ? expr.arguments.map(arg => this.expressionToString(arg)).join(', ') : '';
        return `${funcName}(${args})`;
      case 'MemberAccess':
        return `${this.expressionToString(expr.expression)}.${expr.memberName}`;
      case 'IndexAccess':
        return `${this.expressionToString(expr.base)}[${this.expressionToString(expr.index)}]`;
      default:
        return expr.type || '';
    }
  }

  /**
   * Extracts function name from a function call expression
   */
  extractFunctionName(expr) {
    if (expr.type === 'FunctionCall') {
      if (expr.expression.type === 'Identifier') {
        return expr.expression.name;
      } else if (expr.expression.type === 'MemberAccess') {
        return expr.expression.memberName;
      }
    }
    return '';
  }
}

/**
 * Parses Solidity code and extracts functions with their CFGs
 */
export function extractFunctionsFromAST(ast) {
  const functions = [];

  function visit(node) {
    if (!node) return;

    if (node.type === 'FunctionDefinition') {
      functions.push({
        name: node.name || 'fallback',
        node: node,
        visibility: node.visibility,
        stateMutability: node.stateMutability
      });
    }

    // Traverse children
    for (let key in node) {
      if (node.hasOwnProperty(key)) {
        const child = node[key];
        if (Array.isArray(child)) {
          child.forEach(visit);
        } else if (typeof child === 'object' && child !== null) {
          visit(child);
        }
      }
    }
  }

  visit(ast);
  return functions;
}
